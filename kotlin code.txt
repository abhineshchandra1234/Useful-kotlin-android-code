//topics
	//databinding
		//to bind views as well as their data
		//slows the system a bit
		
//to hide actionbar
	supportActionBar?.hide()
//color
	//to pick color    https://material.io/design/color/the-color-system.html#tools-for-picking-colors  
//safe calls
	?. 
//Left alt+enter
	If alt+enter is not working
	
//Firebase console
	https://console.firebase.google.com/u/0/

//Google Api Services
	https://console.developers.google.com/ 

//Internet Permission
	<uses-permission android:name="android.permission.INTERNET" /> 
	
//maven repository
	maven {
	          url 'https://maven.google.com'
	        } 
	 maven { url 'https://jitpack.io' }
//google sign in android
	https://firebase.google.com/docs/auth/android/google-signin

//android studio keyboard shortcuts
	Ctrl+ I – to implement methods
	Ctrl+ O – to override functions
	Ctrl + B – To go to declaration  //u can see function call also,like where the func is called, it will return a list of func calls in case of multiple calls
	Ctrl + D – To duplicate line
	Ctrl + Q - To know about function, type of variable, you can read function description also
	Ctrl + P - To see parameters
	Ctrl + G - to go to particular line in android studio
	Alt + F7 - To find usages
	shift + F6 - to rename files
	tab - right-click -> close other tabs
	Ctrl + Alt + l - To reformat code //useful for xml layout
	Ctrl + / - comment with line comment
	Ctrl + shift + / - comment with block comment //useful for multi line comment 

//to generate constructors
	right-click -> generate -> secondary constructors
//Log statement
	logd -> press enter to autocomplete
//Toast statement
	Toast.makeText(context,"Please enter all the information",Toast.LENGTH_SHORT).show()
	//to change toast on condition
	Toast.makeText(this, if(isChecked) "Geek Mode ON" else "Geek Mode OFF", Toast.LENGTH_SHORT).show()
	toast -> press enter to autocomplete
//Custom Toast	
Toast(this).apply {					
                duration = Toast.LENGTH_LONG		
this is a sample text				
                view = layoutInflater.inflate(R.layout.custom_toast,clToast)
                show()
            }
//SH1 certificate	   
	Gradle-Tasks-android-signingReport
//Intent
	val dashboardIntent = Intent(this, DashboardActivity::class.java)
	startActivity(dashboardIntent)
	//to disable back
	finish()
	Intent(this, ThirdActivity::class.java).also {
                startActivity(it)
            }
	//to pass value through intent
		it.putExtra("EXTRA_NAME",name)
	//to get value from intent
		val name = intent.getStringExtra("EXTRA_NAME")
	//to check null
		errorMsg = intent.getStringExtra("errorMsg") ?: "Invalid User"
//Initialize variable and assign value later		
	private lateinit var
//To build apk	
	Build -> Generate Signed Bundle/apk
	//location
		//D:\Users\prita\AndroidStudioProjects\ViewModelLiveData\app\build\outputs\apk\debug
//to deploy apps	
	google play console
//To move views upwards while using keyboard	
	<activity android:name=".UiActivities.SignInCopy"
            android:windowSoftInputMode="stateVisible|adjustResize"	-- use inside manifest file activity
            />
//To stop views from moving upwards while using keyboard
	<activity android:name=".UiActivities.SignInCopy"
            android:windowSoftInputMode="adjustPan|adjustResize"	-- use inside manifest file activity
            />
//to set image	
	imageView2.setImageResource(bundle!!.getInt("image"))
//recycler view	
	implementation 'androidx.recyclerview:recyclerview:1.1.0'
//to display image from url	
	implementation 'com.squareup.picasso:picasso:2.71828'
//android networking library	
	implementation 'com.amitshekhar.android:android-networking:1.0.2'
//libraries
	//libraries Notes
		//implementation 'com.google.firebase:firebase-firestore-ktx:22.1.0'
		//-ktx -> refers to kotlin version of firestore and it is optimized for kotlin
		//implementation 'androidx.appcompat:appcompat:1.2.0'
		//androidx -> refers to the latest version, android is deprecated
		
	//plugins
	//for referencing views
		id 'kotlin-android-extensions' 
	//data binding		
		id 'kotlin-kapt'
		
	//Dagger - Hilt
		implementation "com.google.dagger:hilt-android:2.31-alpha"
		kapt "com.google.dagger:hilt-android-compiler:2.31.2-alpha"

    		implementation "androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha03"
		kapt "androidx.hilt:hilt-compiler:1.0.0-beta01"
		
		//classpath Dagger - Hilt
		classpath "com.google.dagger:hilt-android-gradle-plugin:2.31-alpha"
		 
		//plugin dagger_hilt
			id 'kotlin-kapt'
			id 'dagger.hilt.android.plugin'
		
	//Activity KTX for viewModels()
    		implementation "androidx.activity:activity-ktx:1.1.0"
	//google sign in 
    		implementation 'com.google.android.gms:play-services-auth:19.0.0'
	// Preferences DataStore
    		implementation "androidx.datastore:datastore-preferences:1.0.0-alpha04"
    
	//coroutines
		implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1'
		implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1'
		implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.1.1'
		
	// Coroutine Lifecycle Scopes
    		implementation  'androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1'
    		implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.3.1"		
		

	//retrofit2
		implementation 'com.squareup.retrofit2:retrofit:2.9.0'
		implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
		implementation 'com.squareup.okhttp3:logging-interceptor:4.5.0'
		implementation 'com.squareup.retrofit2:adapter-rxjava2:2.5.0'
	
	//Navigation Component
		implementation 'androidx.navigation:navigation-fragment-ktx:2.2.2'
		implementation 'androidx.navigation:navigation-ui-ktx:2.2.2'
		
		//plugin navigation safe args dependency
		id 'androidx.navigation.safeargs.kotlin'
		
		//classpath navigation safe args dependency
		classpath "androidx.navigation:navigation-safe-args-gradle-plugin:2.3.1"

     	// Room components
    		implementation "androidx.room:room-runtime:2.2.6"
    		kapt "androidx.room:room-compiler:2.2.6"	//id "kotlin-kapt"
    		implementation "androidx.room:room-ktx:2.2.6"
    		androidTestImplementation "androidx.room:room-testing:2.2.6"

    	//Lifecycle components
		//ViewModel && LiveData
			implementation "androidx.lifecycle:lifecycle-extensions:2.2.0"
		implementation "androidx.lifecycle:lifecycle-common-java8:2.2.0"
		implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0"
		
		def arch_version = '2.2.0-alpha01'
		implementation "androidx.lifecycle:lifecycle-runtime-ktx:$arch_version"

    	// Kotlin components
		implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.3.72"
		api "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.5"
		api "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.5"
		
	// AnyChart components
		implementation 'com.github.AnyChart:AnyChart-Android:1.1.2'
		implementation 'com.android.support:multidex:1.0.3'
		multiDexEnabled true -- inside defaultConfig
		
	//ViewModel and LiveData
		implementation 'androidx.lifecycle:lifecycle-extensions:2.2.0'

    	//Recyclerview
    		implementation 'androidx.recyclerview:recyclerview:1.1.0'
	//CardView
		implementation "androidx.cardview:cardview:1.0.0"
	//Networking
		implementation 'com.amitshekhar.android:android-networking:1.0.2'

    	// Gson
		implementation "com.google.code.gson:gson:2.8.6"

    	// Glide
		implementation 'com.github.bumptech.glide:glide:4.11.0'

    	// Paging 3
    		implementation "androidx.paging:paging-runtime:3.0.0-beta03"

    	//Rx
		implementation 'io.reactivex.rxjava2:rxjava:2.2.7'
		implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'

//to print log msg
	Log.d("MyIntentService","Service is stopping...")
	
//for api calls
	sample APi or https://reqres.in/

//for viewing json on chrome
	json viewer chrome extensions 
//Kotlin Networking(for api calls)
	Retrofit, Volley 
	 
	ref - https://www.youtube.com/watch?v=sBCE_hOFnQU
//api list
	//cat-facts api
		https://alexwohlbruck.github.io/cat-facts/docs/
		
	//fake api
		https://reqres.in/
		
	//fake api - Free to use fake Online REST API for testing and prototyping
		https://jsonplaceholder.typicode.com/
		
	//Documentation and Test Consoles for Over 1400 Public APIs
		https://public-apis.io/
		
	//to generate fake api
		https://www.mockable.io/a/#/
		
	//Foreign exchange rates API
	with currency conversion
		ref - https://exchangeratesapi.io/
		
	//Api
		//Big List of Free and Open Public APIs (No Auth Needed)
		ref - https://mixedanalytics.com/blog/list-actually-free-open-no-auth-needed-apis/	
		
	//News api key
		//ref - https://newsapi.org/
		//1aef8bff01b34e56b931da95d6c2330f
	
	//best api generator
	//random-data-api
		//ref - https://random-data-api.com/documentation
		
	//public api
		//ref - https://github.com/public-apis/public-apis#health
		
//change actionbar name
	setupActionBarWithNavController(findNavController(R.id.fragment))
	
//Debugging
	verbose - caused by or general error msg
	//put breaking points using debugger and see values going step by step or go inside function if found error

//Git
	you can control android using local gitbash
//push code to github
	open git bash at desired location
	git init - to initialize the repository
	git add . - to add all the files to the given folder.
	git status - to view all the files which are going to be staged to the first commit.
	git commit -m 'first commit' - which adds the change to the local repository.
	The HTTPS or URL is copied from the given GitHub account, which is the place of the remote repository.
	git remote add origin 'your_url_name'
	git push -u origin master - used for pushing local content to GitHub. master is the local branch name from which data is being pushed. you can give other branch name 	
	also eg - second, third
	//to check origin
		git remote -v
	//git delete local repository 
		view tab -> show hidden files -> Delete the .git directory 
		ref - https://stackoverflow.com/questions/1514054/how-do-i-delete-a-local-repository-in-git
	//change remote url git
		git remote set-url origin "https://github.com/abhineshchandra1234/repository.git"
		https://github.com/abhineshchandra1234/repository.git
	
		//to see commit details.	
			git log -  Press "enter" to scroll. Press "q" to exit log view. It will show head and below commits. (using android)
		//to see all commits
			git log --all (using android). It will show all commits including head.
		//revert commmit
			terminal -> git revert hash_code (commit you want to remove. eg- 4 hash will remove 4th commit)
			git -> select the commit you want to revert -> right click -> revert  (using android)
		//switch or checkout to particular commit
			terminal -> git checkout hash_code (commit you want to switch to. eg- 4 hash will switch to 4th commit)
			git -> select the commit you want to checkout -> right click -> checkout revision 'abcd' (using android)
		//yellow tag will show the current head
		//stash
			git stash -> to save local changes which you have not committed before you checkout to other commit. It will create local commit.
			git stash list -> to get list of stash in its current commit.
			git stash apply -> to apply the changes
			//Dont checkout to stash commit it will complicate things just get data using "stash list"
			easier method
			vcs -> git -> Stash Changes -> stash_name -- to stash local changes
			vcs -> git -> UnStash Changes -> select the required stash -- to unstash local changes
			
//branching git
	//you can use this to create diff versions of your project and it will have its own seperate commits
	//git branch -> it will show a list of branches
	//git checkout feature -> you can use this to switch between branches where feature is the branch name
	//git checkout -b non-existing-branch -> switched to a new branch non-existing
	//git branch -d localBranchName -> delete branch locally
	//git push origin --delete remoteBranchName -> delete branch remotely
	//git fetch -p -> The -p flag means "prune". After fetching, branches which no longer exist on the remote will be deleted.
			
//android git
	//remove buggy local code
		//select latest commit -> Reset current branch to here -> Hard -> all local changes will be lost

//pull code from github
	//merge remote changes to local
		git pull 'remote_name' 'branch_name'
		//it is useful for readme files error or someone else made changes to remote repo
	shortcut
		//shift+home - home
		//shift+end - end
		//ctrl+l - clear screen
		//shift + insert -  to copy commands in bash
		
		
	
	ref - https://www.datacamp.com/community/tutorials/git-push-pull

//reset code in android studio
	//select the desired commit
	//right click -> reset current branch to here -> hard //it will remove your local changes
	//build -> rebuild project //it is imp for reset of code base
	//it will remove your local changes and reset the project to the desired commit
	
	
//fonts
	https://fonts.google.com/
	search font.ttf
	android:font="@fonts/custom.ttf"
	

//custom toolbar
	https://youtu.be/e5_C9e_gKOM

//redo
	ctrl+shift+z
	
//to find recruiters
	company_name recruiter on linkedin
	find maild id and send resume
	
//animations
	button or icon animation
	ref - 
	https://youtu.be/ALj2KO7CAqM
	Web App: https://shapeshifter.design/
	Project: https://github.com/alexjlockwood/ShapeShifter
	
//APi 
	SimpleApi
	Repository
	MainViewModel
	//plugin
		implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
	//parsing
		edit post class to receive data
		convert response from class to string 
		ref - https://medium.com/@hissain.khan/parsing-with-google-gson-library-in-android-kotlin-7920e26f5520
		to access nested data
		val user: ArrayList<User>
		to get nested data value
			iterate json array
			ref - https://stackoverflow.com/questions/17441246/org-json-jsonarray-cannot-be-converted-to-jsonobject
	//Code
		/*
			if (response.isSuccessful) {

			val jsonString = Gson().toJson(response.body())
			val obj = JSONObject(jsonString)

			Log.d("Main", response.body().toString())
			Log.d("Main", response.code().toString())
			Log.d("Main", response.headers().toString()) //to see header details
		    	}
		*/
	//Parsing Array Response
		/*
			userinfo = obj.getString("user")
			    val jsonarray = JSONArray(userinfo)
			    for (i in 0 until jsonarray.length()) {
				val jsonobject = jsonarray.getJSONObject(i)
				username  = jsonobject.getString("name")
				useremail = jsonobject.getString("email")
				rack_available = jsonobject.getString("rack_available")
			    }
		*/			    
	//data change
		change the data class for that particular object only , no need to recreate data classes for all json objects
		eg - if new variable is added in User object, change only User data class
	//always use json class to kotlin to generate data class
	//post request
		match post rqst variable before sending post request otherwise validation error will come
	//to check api
		use postman and save diff urls, you can also group urls based on project.
	
	//response
		//response successfull
		//use function to perform operations if the response is successful for cleaner code
		
	//Note Api
		//we cannot call api(viewmodel) from service class. viewmodel is closely associated with lifecycle of activity and can be called from activity only.
		//just create parameters for which you want data in Data class. No need to create all the parameters of response
		//you will get response for the parameters you created
	
	//Header
		//it is metadata which is sent with every api request
		//it can be static and dynamic both.
		//you can have fixed header or dynamically define your header for api request
		
		//libs
			//implementation 'com.squareup.okhttp3:logging-interceptor:4.5.0'
	
	//Another Api in same project
		//just create a new api class or interceptor class
		//and you can call as many api as you want inside same app
		/*
		interface TokenLocalApi {
		    @FormUrlEncoded
		    @POST("updateToken.php")
		    suspend fun pushTokenDetailsLocal(
			    @Field("token_type") token_type: String,
			    @Field("expires_in") expires_in: String,
		    ): Response<TokenResponse>
		}
		*/
		
	//Calling Api Directly without MVVM
		//Code
		/*
		 private fun pushTokenDetails() {
			Log.d("Main", "pushTokenDetails is called")
			AndroidNetworking.initialize(this)
			AndroidNetworking.post("https://saml1.eegrab.com/saml/test/API/updateToken.php")
			    .addBodyParameter("token_type", "1")
			    .addBodyParameter("expires_in", "2")			  
			    .setOkHttpClient(RetrofitInstance.getUnsafeOkHttpClient()?.build())
			    .build()
			    .getAsObject(TokenDatabase::class.java, object : ParsedRequestListener<TokenDatabase> {

				override fun onError(anError: ANError?) {
				    TODO("Not yet implemented")
				}

				override fun onResponse(response: TokenDatabase?) {
				    Log.d("Main", "Token Database response is $response")
				}

			    })
		    }
		    */
		    //Ref
		    	//https://youtu.be/rBQi_7L-Uc8
			//documentation - https://github.com/amitshekhariitbhu/Fast-Android-Networking
	
	//Calling Api best practice
		//use viewmodel to call api 
			//advantages
				//api will not get called again when you rotate your screen
				//api will not get called again when you come back to base fragment
				//this happens because viewmodel has its own lifecycle
//MQTT
	add libraries
	add connect,publish,subscribe
	add permissions in manifest
	makes changes in application tab in manifest
	
	
//drawable
	copy asset by creating a folder and pasting in res folder
	
//swipe view
	use viewpager2 to create swipe views
	ref - https://youtu.be/COZ3j8Dwlog
	Steps
	//add fragment in xml file
	//call mynav file from there
	//in mynav pass viewpagerfragment
	//viewpagerfragment will contain all the fragments 
	//you need to create viewpageradapter also for viewpagerfragment
//Http request
	add android:usesCleartextTraffic="true" inside application tag to read data
	
	
//Delay
	Handler(Looper.getMainLooper()).postDelayed({
      //Do something after 100ms
    }, 100)
    
//Singleton
	to access same variable and functions across different activities
			
		
//Fullscreen Mode
	override fun onCreate(savedInstanceState: Bundle?) {
    requestWindowFeature(Window.FEATURE_NO_TITLE)
    super.onCreate(savedInstanceState)     
    window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
            WindowManager.LayoutParams.FLAG_FULLSCREEN)
   setContentView(R.layout.activity_test_test)
   }
   ref  - https://stackoverflow.com/questions/45408167/how-to-create-the-activity-full-screen-in-android-programmatically-using-kotlin/45408235
   
//Activity lifecycle
	//when activity is visible
		onCreate	called when activity is first created.
		onStart		called when activity is becoming visible to the user.
		onResume	called when activity will start interacting with the user.
	//when activity is stopped
		onPause		called when activity is not visible to the user.
		onStop		called when activity is no longer visible to the user.
	//when activity is again visible
		onRestart	called after your activity is stopped, prior to start.
	//when app is closed
		onDestroy	called before the activity is destroyed.
	
	//Order of calling funcs
	
	//when you open the app
		//onCreate is called
		//onStart: is called
		//onResume: is called
	//when you minimize the app
		//onPause: is called
		//onStop: is called
	//when you reopen the app
		//onRestart: is called
		//onStart: is called
		//onResume: is called
	//when you change the orientation of the app
		//onPause: is called
		//onStop: is called
		//onDestroy: is called
		//onCreate is called
		//onStart: is called
		//onResume: is called
	//when you kill the activity while moving to other activity eg - finish()
		//onPause: is called
		//onStop: is called
		//onDestroy: is called
		
//Fragment lifecycle
	//when you open the app
		//onAttach: is called
		//onCreate: is called
		//onCreateView: is called
		//onViewCreated: is called  //ignore this
		//onActivityCreated: is called
		//onStart: is called
		//onResume: is called
	//when you minimize the app		
		//onPause: is called
		//onStop: is called
	//when you reopen the app
		//onStart: is called
		//onResume: is called
	//when you change the orientation of the app
		//onPause: is called
		//onStop: is called
		//onDestroyView: is called
		//onDestroy: is called
		//when you open the app, methods is called
	//when you move from one fragment to another
		//onPause: is called
		//onStop: is called
		//onDestroyView: is called
//Services
	ref - https://youtu.be/EwwB_wZhBaw
	//intent
	val intent1 = Intent(this@MyService, ApiActivity::class.java)
                        intent1.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        this@MyService.startActivity(intent1)
			
	Keeps running once started only stop manually or when app is killed
	//Intent service
		runs automatically in sepearate thread not able to do multi-threading
	//Service
		runs in the main thread, manually specify seperate thread, able to do multi-threading
		//sepearate thread
			 Thread{
			}.start()
			
	//Services
	ref - https://www.tutorialspoint.com/how-to-run-an-android-service-always-in-the-background-using-kotlin
	//foreground services
		//if you want to run something even if the app is closed
	ref - https://androidwave.com/foreground-service-android-example-in-kotlin/
			
//java to kotlin code
	code -> convert java to kotlin code
	
//rename variable
	select variable -> refractor -> rename

//location of files github

//gradle location github
	//project level
		outside -> build.gradle
	//module level
		app -> build.gradle
		
//layout location github 
	//DataStoreAndroid/app/src/main/res/layout/activity_main.xml
	
//Activity location github 
	//DataStoreAndroid/app/src/main/java/com/plcoding/datastoreandroid/MainActivity.kt
	
//common location
	//DataStoreAndroid/app/src/main/
		//java - Activity
		//res - layout
		//AndroidManifest.xml

		
//view binding
	//it is a very powerful lib
	//it avoids confusion between same views having same id, It will only show id of view associated with activity or fragment
	//you can give views same id in multiple layout bcs you can only access views of layout associated with binding object
	Module gradle
	 defaultConfig {
	 	...
	 }
	 buildFeatures {
        	viewBinding true
    		}
		
	MainActivity
		private lateinit var binding: ActivityMainBinding // every layout file will have its own binding class
		oncreate{
		 	binding = ActivityMainBinding.inflate(layoutInflater)	//replace setContentView(R.layout.activity_main) with these two lines
        		setContentView(binding.root)
	
			binding.btnShowSnackbar.setOnClickListener {
            		...
        		}
		}
	//for fragment
		class SampleFragment : Fragment(R.layout.fragment_sample)
		private lateinit var binding: FragmentSampleBinding
		binding = FragmentSampleBinding.bind(view)
        	binding.tvFrag.text = "Chandra"
		
//data binding
	//plugin
		//id 'kotlin-kapt'
	Module gradle
	 defaultConfig {
	 	...
	 }
	 buildFeatures {
        	dataBinding true
    		}
	//use
		/*
		<layout
    		xmlns:android="http://schemas.android.com/apk/res/android"
    		xmlns:app="http://schemas.android.com/apk/res-auto"
    		xmlns:tools="http://schemas.android.com/tools"
    		> 
		<data>
        		<variable
            		name="myViewModel"
            		type="com.eegrab.roomdemo.SubscriberViewModel" />
    		</data>
		//xml code
		<Button
		    android:id="@+id/btnSaveUpdate"
		    android:layout_width="wrap_content"
		    android:layout_height="wrap_content"
		    android:text="@={myViewModel.saveOrUpdateButtonText}"
		    android:onClick="@{()->myViewModel.saveOrUpdate()}"  
		    android:textSize="18sp"
		    android:textStyle="bold"
		    android:layout_weight="1"
           	 />
		</layout>
		*/
	//MainActivity
		private lateinit var binding: ActivityMainBinding
		onCreate{
			setContentView(R.layout.activity_main)
        		binding = DataBindingUtil.setContentView(this,R.layout.activity_main)
		}
//ViewModel
	/* 
	class SubscriberViewModel(private val repository: SubscriberRepository): ViewModel() {
		@Bindable
		val inputName = MutableLiveData<String>()
		@Bindable
		val inputEmail = MutableLiveData<String>()
		
		init {
		saveOrUpdateButtonText.value = "Save"
		clearAllOrDeleteButtonText.value = "Clear All"
    			}
		
		fun saveOrUpdate(){

    		}
	}
	*/
//Scope Functions		
//Elvis Operator
	When we have a nullable reference b, we can say "if b is not null, use it, otherwise use some non-null value":
	val l: Int = if (b != null) b.length else -1
	val l = b?.length ?: -1
	
//Also
	fun getSquaredI() = (i*i).also {
        i++
    } 
    //it will increase i value also and if used (it) it will increase (i*i) value
    
//Let 
	It is equivalent to also
    
//Apply
	val intent = Intent().apply {
            putExtra("","")
            putExtra("",0)
            action = ""
        }
	it will return intent object with all below functions. You can use it to start new activity. It will serve as intent class and you can access
	every function of it.
	
//Run 
	It is equivalent to apply it will return the last line eg -  (action = "") or (this) to return intent
	
//With
	It is equivalent to run
	with(Intent()) {
	..
	}
	
//to add webview to app
webView.settings.javaScriptEnabled = true
        webView.settings.domStorageEnabled = true
        webView.webViewClient = object : WebViewClient() { -- to open webview inside app
        override fun shouldOverrideUrlLoading(view: WebView, url: String?): Boolean {
            view.loadUrl("https://abcd.com")
            return true
        }

//            fun onPageFinished(view: WebView?, url: String?) {
//            }
        }
	webView.destroy()
        webView.removeAllViews()
        webView.clearCache(true)
        webView.clearHistory()
        webView.clearView()
        webView.loadUrl("https://abcd.com") 
	
	
        webView.clearView()  -- most important to add before you load new url
        webView.loadUrl("https://abcd.com") -- to open webview outside app

//debug code
	timestamp = Timestamp(System.currentTimeMillis())
        Log.d(MainActivity.Singleton.TAG, "api is called" + timestamp)
	
//change background on buttonclick
	 twoBtn.setOnClickListener {
            twoBtn.setBackgroundResource(R.drawable.ic_selected)
        }
//Job Sites
	//https://tophire.co/home?
    
//to remove ssl error in retrofit
	Retrofit.Builder()
                .baseUrl(BASE_URL)
                .client(getUnsafeOkHttpClient()?.build())
                .addConverterFactory(GsonConverterFactory.create())
                .build()
		
	 fun getUnsafeOkHttpClient(): OkHttpClient.Builder? {
        return try {
            // Create a trust manager that does not validate certificate chains
            val trustAllCerts = arrayOf<TrustManager>(
                    object : X509TrustManager {
                        @Throws(CertificateException::class)
                        override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {
                        }

                        @Throws(CertificateException::class)
                        override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {
                        }

                        override fun getAcceptedIssuers(): Array<X509Certificate> {
                            return arrayOf()
                        }
                    }
            )

            // Install the all-trusting trust manager
            val sslContext = SSLContext.getInstance("SSL")
            sslContext.init(null, trustAllCerts, SecureRandom())

            // Create an ssl socket factory with our all-trusting manager
            val sslSocketFactory = sslContext.socketFactory
            val builder = OkHttpClient.Builder()

            builder.sslSocketFactory(sslSocketFactory, trustAllCerts[0] as X509TrustManager)
            builder.hostnameVerifier(HostnameVerifier { hostname, session -> true })
            builder
        } catch (e: Exception) {
            throw RuntimeException(e)
        }
    }
    
    ref - https://mobikul.com/android-retrofit-handling-sslhandshakeexception/
	
//to protect eyes
	install flux and set current location
		
//disable onclick
	oneBtn.isEnabled = false

//Spinner
	//set default spinner position
		val spinnerPosition: Int = adapter.getPosition("text")
		spinner.setSelection(spinnerPosition)
	//to set entries
		android:entries="@array/currency_codes"
//Visibility
	visible -- view will be visible and user will not be able to interact
	invisible -- view will be invisible and user will not be able to interact
	gone -- view will be invisible and the space will also be removed
	constraintLayoutKeysSignIn.isVisible = false -- to set visibility
	binding.rvNotes.visibility = View.GONE -- to set visibility
	binding.tvEmptyNote.visibility = View.VISIBLE
	
//editText
	//disable special characters
		android:digits="abcde.....012345789"
	//to get text
		ritm = etRitmKeys.text.toString()
	//to set text
		etRitmKeys.setText(ritm)
		
//modern editText
	/*
	<com.google.android.material.textfield.TextInputLayout
        android:id="@+id/tilFrom"
        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox.Dense"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:hint="Amount"
        android:layout_marginEnd="16dp"
        app:layout_constraintBottom_toBottomOf="@+id/spFromCurrency"
        app:layout_constraintEnd_toStartOf="@+id/spFromCurrency"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="@+id/spFromCurrency">

        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/etFrom"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:inputType="numberDecimal" />
    </com.google.android.material.textfield.TextInputLayout>
    */
    
    
    
//pass views as parameter
	//just name the function and pass the view. It will generate the code automatically
	private fun changeView(view: TextView) {
        if (view.text in keysList) {
            view.setBackgroundResource(R.drawable.ic_available)
        }
        else {           
            view.setBackgroundResource(R.drawable.ic_selected)
        }       
    }

//type
	val obj: Double = 5.0
	System.out.println(obj.javaClass.name)                 // double
	System.out.println(obj.javaClass.kotlin)               // class kotlin.Double
	System.out.println(obj.javaClass.kotlin.qualifiedName) // kotlin.Double
	
//flowchart
	https://app.creately.com/diagram/ZKvvxZLiEHb/edit	//paid better UI
	https://cloud.smartdraw.com/editor.aspx?templateId=490dad73-de30-42bf-9a58-1789d56c1afd&flags=128#depoId=25165452&credID=-33813377	//free
	
//click effect for btn
	android:clickable="true"
    android:focusable="true"
    
//recyclerview  
	//to create recyclerview
		ref - https://youtu.be/UCddGYMQJCo
		ref - https://medium.com/@aayushpuranik/recycler-view-using-kotlin-with-click-listener-46e7884eaf59 -- to implement onclick in base activity
	//efficient onclick
		you can simplify it further by calling function inside ViewHolder class and passing view and position to it
		keyCollectionRequest(itemView,position)
	//more efficient way is using higher order function of kotlin
	adapter = RecyclerNewAdapter(this)
        rv_recyclerView.adapter = adapter
	//Kotlin - RecyclerView List Data From JSON API
	ref - https://youtu.be/rBQi_7L-Uc8
	
	ref - https://www.tutorialspoint.com/working-with-recyclerview-in-an-android-app-using-kotlin
	//to add click 
	//inside onBindViewHolder
	holder.movieLayout.setOnClickListener {
            Toast.makeText(holder.title.context,"title is "+movie.getTitle(),Toast.LENGTH_SHORT).show()
        }

    
	//how to change recyclerview to gridview
		private var gridLayoutManager: GridLayoutManager?= null
		gridLayoutManager = GridLayoutManager(applicationContext,3, LinearLayoutManager.VERTICAL,false)
        	rv_recyclerView?.layoutManager = gridLayoutManager
		//just change the layout manager of recyclerview
	 
	//preview
		<androidx.recyclerview.widget.RecyclerView
		tools:listitem="@layout/example_item" //useful if you want to see your recyclerview with filling layout
		/>
		
	//RecyclerView Intent
		val context=holder.title.context
		val intent = Intent( context, EventDetail::class.java)
		context.startActivity(intent)
		ref - https://stackoverflow.com/questions/59012821/android-kotlin-new-intent-on-click-event-from-recycler-view		
		
	//intent for recycler view adapter
		ref - https://stackoverflow.com/questions/59012821/android-kotlin-new-intent-on-click-event-from-recycler-view		
		
	//update data
		//Use DiffUtil to Improve RecyclerView's Performance 
		//It will only update data which has changed, it will not update the entire list
		//It will also check duplicate data and will not allow entry of duplicate data
		
	//populate recyclerview with retrofit response
		//response.body()?.let {  myAdapter.setData(it)	}
		
	//add scroll to RecyclerView
		//android:scrollbars="vertical"
		
	//add swipe feature to RecyclerView
		//Code
		/*
				val itemTouchHelperCallback = object : ItemTouchHelper.SimpleCallback(
			    ItemTouchHelper.UP or ItemTouchHelper.DOWN,
			    ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT
			) {
			    override fun onMove(
				recyclerView: RecyclerView,
				viewHolder: RecyclerView.ViewHolder,
				target: RecyclerView.ViewHolder
			    ): Boolean {
				TODO("Not yet implemented")
			    }
				//func on what to do when item is swiped
			    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {
				val position = viewHolder.adapterPosition
				val article = newsAdapter.differ.currentList[position]
				viewModel.deleteArticle(article)
				Snackbar.make(view,"Successfully deleted article", Snackbar.LENGTH_LONG).apply {
				    setAction("Undo") {
					viewModel.saveArticle(article)
				    }
				    show()
				}
			    }
			}
			//to attach swipe feature to recycler view
			ItemTouchHelper(itemTouchHelperCallback).apply {
			    attachToRecyclerView(rvSavedNews)
			}
		*/		
//DiffUtil
	/*
	private val differCallback = object : DiffUtil.ItemCallback<Article>() {
        override fun areItemsTheSame(oldItem: Article, newItem: Article): Boolean {
            return oldItem.url == newItem.url	//it should be unique
        }

        override fun areContentsTheSame(oldItem: Article, newItem: Article): Boolean {
            return oldItem == newItem
        }

	    }

	    val differ = AsyncListDiffer(this,differCallback)
	
	getItemCount{
	return differ.currentList.size
	}
	onBindViewHolder {
		val article = differ.currentList[position]
	holder.itemView.apply {       
            tvTitle.text = article.title
            tvDescription.text = article.description
	}
	*/
//cardview
	//round
		android:layout_width="100dp"
        	android:layout_height="100dp"
	//background
		ref - https://stackoverflow.com/questions/27299291/drawable-as-background-for-cardview
	//click effect
		android:clickable="true"
        	android:focusable="true"
	//attribute
		app:cardBackgroundColor="@color/design_default_color_primary"
        	app:cardCornerRadius="10dp"
		app:cardElevation="10dp"
	//Expandable CardView
		//ref - https://www.geeksforgeeks.org/how-to-create-an-expandable-cardview-in-android/
//appname
	//change appname
		//change label in application tag in manifest
		android:label="@string/app_name"

//Listener
	//Todo
		Detail explanation

	
//Constraint layout
	//to remove constraint
		select view -> right click remove constraint for that view
		whole view -> toolbar -> clear all constraints -> it will remove constraints of all the views
		
		ctrl + select respective constraint - It will remove that particular constraint
		
	//to spread view equally to occupy screen
		select two view atleast -> right click -> chains -> create horizontal or vertical chains
	//to select multiple views
		use mouse and select all views in design tab
	//alignment
		//it will align views according to constraints given
		//eg -  app:layout_constraintStart_toStartOf="@+id/spFromCurrency" //here base view start will aligned to start of destination view
		// app:layout_constraintBottom_toBottomOf="@+id/btnConvert"   //here base view bottom will only be aligned to bottom of destination view
		//if you add app:layout_constraintTop_toTopOf="@+id/btnConvert" then base view top will only be aligned to top of destination view and base view will be
		//in center of destination view
	//center
		//you can center your view with respect to other view
		//just align top, left and right of base view with respect to destination view
		
	//center view in screen
		//use tools to constraint view horizontally && vertically in parent
		//it will align the view automatically in center of screen
		
//Guideline
	//you can use it to align views on screen 
	//eg - guideline1 - 35%
	//guideline2 - 65%
	//views will be between these guidelines		
	//It is very powerful concept
	//just constraint views to guideline eg - using constraint layout and you
	//can shift guideline up or down (horizontally) or left or right (vertically) and all the views constrained to guideline will also be shifted

		
	
//productive apps
	//mobile
		To do List
	//web
		https://app.asana.com/
	
//TextView
	//Change text color of one word in a TextView
		val first = "Welcome "
		val next = "<font color='#EE0000'>Abhinesh Chandra</font>"
		textView2Choice.setText(Html.fromHtml(first + next))
		ref - https://stackoverflow.com/questions/7221930/change-text-color-of-one-word-in-a-textview
	//to adjust text within textview dimension
		android:autoSizeTextType="uniform"
		android:singleLine="true" //to keep text in one line
	//code
		android:textStyle="bold"  // to change text style
		android:textColor="@color/black" //to change text color
	//attribute
		android:textSize="30sp"
		app:drawableStartCompat = "@drawable/ic_person" //to add a icon at start of textview
		android:maxLines="1" //text will be in one line only irrespective of length
        	android:ellipsize="end" //it will give dot effect at end if text is long
		android:drawablePadding="4dp" //it will add padding between icon and text 
	
//project name 
	//Change project name on Android Studio
		If your settings.gradle contains the below line, either delete it or update it to the new name.
		rootProject.name = 'Your project name'

//project structure
	create package with proper naming convention and place activities in respective folder
	
//back button
	//disable back button
	//override method and do nothing
	override fun onBackPressed() {
		//if (shouldAllowBack()) {
		//super.onBackPressed()			
		//} else {
		//doSomething()
		//}
    	}
	ref - https://stackoverflow.com/questions/4779954/disable-back-button-in-android
	
//alert dialog
	you can create a basic alert dialog with title, message, positive (yes), negative (no) views
	ref - https://www.youtube.com/watch?v=MMcfdEzfdB4
	   val builder = AlertDialog.Builder(this)
        builder.setTitle("Are you sure!")
        builder.setMessage("Do you want to close the app?")
        builder.setPositiveButton("Yes",{ dialogInterface: DialogInterface, i: Int ->
            finish()
        })
        builder.setNegativeButton("No",{ dialogInterface: DialogInterface, i: Int -> })
	builder.setNeutralButton("Ok",{ dialogInterface: DialogInterface, i: Int -> })
        builder.show()
	 val alert = builder.create()
        Handler(Looper.getMainLooper()).postDelayed({
            //Do something after 100ms
            alert.dismiss() 		--> to dismiss dialog ater few seconds
        }, 3000)
        alert.show()
	you can also create custom alert dialog with checkbox, edit text and buttons
	ref - https://www.youtube.com/watch?v=PqRp3-t9GPM
	
	//to show simple alert dialog
	//Code
	/*
	AlertDialog.Builder(this)
            .setTitle("Not compatible")		//it will show a simple alert dialog && when clicked on yes it will dismiss and do nothing
            .setMessage("Your phone does not support Bluetooth")
            .setPositiveButton("yes") { _, _ ->
	    //do something
            }
            .show()
	*/	    
	//docs ref - https://www.journaldev.com/309/android-alert-dialog-using-kotlin
//timer
	val timer1 = object: CountDownTimer(5000, 1000) {	//declare it as global variable
        override fun onTick(millisUntilFinished: Long) {
            Log.d(TAG, "timer is running")
        }
        override fun onFinish() {
            Log.d(TAG, "timer finished")
        }
    	}
	timer1.cancel()  //to cancel previous run		//call this inside function
        timer1.start()	//to start new run
	//to show timer
		//use a textview to display timer and update its value	
		var min = millisUntilFinished / 1000 / 60
            	var secs = millisUntilFinished / 1000
            	Log.d(TAG, "time remaining is $min : $secs")
//loop  
	val mainHandler = Handler(Looper.getMainLooper())
                            mainHandler.post(object : Runnable {	//to run anything in loop after every 1 sec
                                override fun run() {   
					//run anything here
                                    mainHandler.postDelayed(this, 1000)
                                }
                            })
//Notification
	ref - https://www.tutorialspoint.com/how-to-create-a-notification-alert-using-kotlin
	
//to check build version
	if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { } //it will check for oreo version(O)
	
//views and layout
	you change any view or layout to different types
	change default text view to other type for faster development
	
//Receiver 
	//declare Receiver in manifest
	 <receiver android:name=".MainActivity$Receiver" />
    	</application>
	
//AlarmManager	
	//to do some task at a paticular time
	ref - https://youtu.be/rzxgQOo2ZF4
	alarmManager.set(AlarmManager.RTC_WAKEUP,System.currentTimeMillis() + second,pendingIntent)
	set method is enough to get data at exact time
	setExact method throws error
	
//TODO
	//it is useful for writing function you want to implement later
	private fun checkLoggedInState() {
        TODO("Not yet implemented")
    	}
	
//null check for functions
	auth.currentUser?.let {
        }
//Firebase
	//connectivity
		tools -> Firebase -> Authentication -> Email & password authentication -> connect your app to firebase 
		//just follow the steps afer that & your app will be connected
	//add firebase authentication
		tools -> Firebase -> Authentication -> Email & password authentication -> add firebase authentication
		//just accept changes and authentication will be added
		ref - https://youtu.be/xu3bHQWD6A0
		//add coroutines dependencies from above for effectiveness
		//email
			//enable email 
			//enable email(passwordless) -> doesnt required password, link will be sent to the email
	//calling diff firebase function
		//its easy:)
		//create instance of firebase
			auth = FirebaseAuth.getInstance()
		//call diff methods on auth
			eg - auth.createUserWithEmailAndPassword(email,password).await() //to create user with email && password
				auth.signInWithEmailAndPassword(email,password).await() //to login user with email && password
				auth.signOut() //to sign out user
	//google sign in
		//add coroutines dependency from above
		//google sign in dependency

	//phone authentication
		//firebase doesnt provide user phone no
		//there is limitation on OTP for testing, so add testing no then test
		//app ref - https://github.com/abhineshchandra1234/UserProfilePhoneAuth
		
//Coroutines
	//def
	Its like multithreading but it can do so much better than multithreading
	You can start task in diff thread other than main thread
	Once the app is closed the coroutines threads will also close
	//call
		add coroutines dependencies
		GlobalScope.launch {
            	delay(3000L)	//it is used to delay the coroutines call
            	Log.d(TAG, "Coroutine says hello from thread ${Thread.currentThread().name}")
        	}
	//context
		//context Notes - we are only allowed to change UI in Main Dispatchers
		//Dispatchers type
			//Dispatchers.Main, IO, Default, Unconfined
	It is used to run coroutines in diff threads by switching between them
	/* GlobalScope.launch(Dispatchers.IO) {	//to run in worker thread
            Log.d(TAG, "Starting coroutine in thread ${Thread.currentThread().name}")	//Starting coroutine in thread DefaultDispatcher-worker-2
            val answer = doNetworkCall()
            withContext(Dispatchers.Main)  {    //to switch back to main thread
                Log.d(TAG, "Setting text in thread ${Thread.currentThread().name}")	//Setting text in thread main
                tvDummy.text = answer
            }
        } */
	//runBlocking //it will run on main thread and will block main thread
	/* Log.d(TAG, "Before runblocking")
        runBlocking {
            Log.d(TAG, "Start of runblocking")
            launch {	//it can be used to launch one or more coroutines inside coroutine
                delay(3000L)
                Log.d(TAG, "finished coroutine 1")
            }
            launch {
                delay(3000L)
                Log.d(TAG, "finished coroutine 2")
            }
            delay(5000L)
            Log.d(TAG, "End of runblocking")
        }
        Log.d(TAG, "After runblocking") */
	//types
		//Dispatchers.Main, Default, IO, unconfined // it refers to diff types of threads
		//Dispatchers.Main - 
			//Use this dispatcher to run a coroutine on the main Android thread. This should be used only for interacting with the UI and performing quick work.
		//Dispatchers.IO -
			//This dispatcher is optimized to perform disk or network I/O outside of the main thread.
		//Dispatchers.Default - 
			//This dispatcher is optimized to perform CPU-intensive work outside of the main thread.
	//Coroutines jobs
	val job = GlobalScope.launch(Dispatchers.Default) {		//it will return job
                repeat(5) {	//it will repeat for five times
                    Log.d(TAG, "Coroutine is still working...")
                    delay(1000L)
                }
        }
	runBlocking {
            job.join()	//it will block the main thread until the job is finished then continue
	    job.cancel() //it is used to cancel job
            Log.d(TAG, "Main Thread is continuing...")
        }
	//output
	Coroutine is still working...
	2021-02-25 11:34:06.454 10665-10732/com.eegrab.coroutineexample D/MainActivity: Coroutine is still working...
	2021-02-25 11:34:07.457 10665-10732/com.eegrab.coroutineexample D/MainActivity: Coroutine is still working...
	2021-02-25 11:34:08.459 10665-10732/com.eegrab.coroutineexample D/MainActivity: Coroutine is still working...
	2021-02-25 11:34:09.462 10665-10732/com.eegrab.coroutineexample D/MainActivity: Coroutine is still working...
	2021-02-25 11:34:10.466 10665-10665/com.eegrab.coroutineexample D/MainActivity: Main Thread is continuing...
	//cancel
		 if (isActive) {  //if some job is not getting cancelled with job.cancel() add instructions inside isActive then call job.cancel()
                        //some action
                    }
		/* val job = GlobalScope.launch(Dispatchers.Default) {
            		Log.d(TAG, "Starting long running process")
            		withTimeout(3000L) {	//it will automatically cancel the job after 3 secs
                	for (i in 30..40) {
                    	if (isActive) {
                        Log.d(TAG, "i is $i")
                        delay(1000L)
                    	}
                	}
            	}
            	Log.d(TAG, "Ending long running process")
        	} */
		//output /*
		Starting long running process
		i is 30
		2021-02-25 12:12:45.067 11840-11910/com.eegrab.coroutineexample D/MainActivity: i is 31
		2021-02-25 12:12:46.069 11840-11910/com.eegrab.coroutineexample D/MainActivity: i is 32
		*/
	//Async and Await
		/* GlobalScope.launch(Dispatchers.IO) {
            	val time = measureTimeMillis {
                var answer1: String? = null	//it will declare nullable variable
                var answer2: String? = null
                val job1 = launch { answer1 = networkCall1()  } //it will launch new coroutine inside coroutine at same time
                val job2 = launch { answer2 = networkCall2()  }//it will launch new second coroutine inside coroutine at same time
                job1.join()	//it will wait for first coroutine to finish
                job2.join()	//it will wait for second coroutine to finish
                Log.d(TAG, "Answer1 is $answer1")
                Log.d(TAG, "Answer2 is $answer2")
            	}
            	Log.d(TAG, "Requests took ${time/1000} secs")
        	}
    		}

    		suspend fun networkCall1(): String  {
        	delay(3000L)
        	return "Answer 1"
    		}

    		suspend fun networkCall2(): String  {
        	delay(3000L)
        	return "Answer 2"
    		} */
		//output /* 
		Answer1 is Answer 1
		Answer2 is Answer 2
		Requests took 3 secs
		*/
		//best way
			/* GlobalScope.launch(Dispatchers.IO) {
            		val time = measureTimeMillis {
                	val answer1 = async { networkCall1() } //it will not return job but deffered string 
                	val answer2 = async { networkCall2() }	//async is used when coroutine return something, it is more efficient than launch
                	Log.d(TAG, "Answer1 is ${answer1.await()}")	//it will wait for value then print it
                	Log.d(TAG, "Answer2 is ${answer2.await()}")
            		}
            		Log.d(TAG, "Requests took ${time/1000} secs")
        		}  */
			//output /*
			Answer1 is Answer 1
			Answer2 is Answer 2
			Requests took 3 secs
			*/
	//lifecycleScope and viewModelScope
		/* tvDummy.setOnClickListener {
            	lifecycleScope.launch {	//it will destroy the coroutine once the activity is destroyed 	//viewModelScope.launch	//it is used for viewModel lifecycle
                while (true) {
                    delay(1000L)
                    Log.d(TAG, "Still running...")
                }
            	}
            	GlobalScope.launch { //it will keep on running coroutine even if the activity is destroyed
                delay(5000L)
                Intent(this@MainActivity, SecondActivity::class.java).also {
                    startActivity(it)
                    finish()	//it will destroy the resources of base activity
                }
            	}
        	} */
		//output // D/MainActivity: Still running...
	//Coroutines firebase
		//we can integrate firebase with coroutines
		/* data class Person(
 		   val name: String = "",
    		val age: Int = -1
		) 
		
		val tutorialDocument = Firebase.firestore.collection("coroutine")	//it will create object of firestore database
            	.document("tutorial")
       	 	val peter = Person("Peter",25)
        	GlobalScope.launch(Dispatchers.IO) {
            	delay(3000L)
            	tutorialDocument.set(peter).await()	//it will set the database with given data and wait for the process to complete
            	val person = tutorialDocument.get().await().toObject(Person::class.java)	//it will get the data from the database and wait for the process to complete
           	 withContext(Dispatchers.Main) {
                tvDummy.text = person.toString()
            	}
        	}
		
		*/
	
//wifi status
	https://johncodeos.com/how-to-check-for-internet-connection-in-android-using-kotlin/
//toggle button
		https://www.geeksforgeeks.org/togglebutton-in-kotlin/
//bluetooth
		//enable or disable 
		mBluetoothAdapter.enable()
		mBluetoothAdapter.disable()
		//permission
		<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
		
//UI
	//Orientation for preview (O)
	//UI mode
		//you can select diff modes like television,appliance, watch etc to check diff UI looks
	//Night Mode
		//you can select (Night) to see how UI will look in night mode
	//Customize layouts for diff screens sizes
		Orientation for preview (O) -> create other -> choose different qualifiers 
		eg - smallest screen width (smallest width for horizontal or vertical orientation)
		smallest screen width (720) && Screen Orientation (landscape) -> it will generate customize layout for tablets in landscape mode
		
//README
	//always update readme on remote and make a pull request to update local otherwise it will be alot of work
	//cheatsheet - https://github.com/tchapi/markdown-cheatsheet/blob/master/README.md
	
//Android Architecture Component
	//ViewModel 
	//ViewModelFactory
	//LiveData
	//StateFlow
	//ViewModel 
		//It is used to retain data on orientation change
		//Do not use it to store reference to view, activity etc
	//ViewModelFactory
		//It is used to pass arguments to viewmodel.
		//Both viewmodel & viewmodel factory is used in retrofit2
	//LiveData 
		//LiveData is a data holder. It is capable of being observed, it can hold any kind of data, and on top of that, it is also lifecycle-aware.
	//StateFlow
		//LiveData deprecated
		//todo ref - https://youtu.be/Qk2mIpE_riY
//Button
	//small text
		android:textAllCaps="false"

//Repository name
	settings.gradle -> rootProject.name = "CoroutineExample"
	
//time
	/* val time2 = measureTimeMillis {  	// it is used to measure execution time of code
            Log.d(TAG, "hello world")
        }
        Log.d(TAG, "request took ${time2/1000} secs") */
	//output 
	/* 2021-02-25 12:32:29.885 12459-12459/com.eegrab.coroutineexample D/MainActivity: hello world
	2021-02-25 12:32:29.885 12459-12459/com.eegrab.coroutineexample D/MainActivity: request took 0 secs
	*/
//NAVIGATION DRAWER
	//layout
		//DrawerLayout is important as root layout to create NAVIGATION DRAWER
//Menu
	//res -> New -> Android Resource file -> Resource type -> Menu
	//Code
	/*
	<menu xmlns:android="http://schemas.android.com/apk/res/android"
	    xmlns:app="http://schemas.android.com/apk/res-auto">
	    <item
		android:id="@+id/nav_delete"
		android:icon="@drawable/ic_delete"
		android:title="Delete everything"
		app:showAsAction="withText"
		/>
	 	<item
			android:id="@+id/action_search"
			android:icon="@drawable/ic_search"
			android:title="Search"
			app:actionViewClass="androidx.appcompat.widget.SearchView"
			app:showAsAction="ifRoom|collapseActionView" //it will expand && collapse on click
        	/>
	</menu>
	
	*/
	//Integration
		//NotesUpdation.kt
		/*
		onViewCreated{
		...
		setHasOptionsMenu(true)
		}
		override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
			inflater.inflate(R.menu.delete_menu,menu)
		    }

		    override fun onOptionsItemSelected(item: MenuItem): Boolean {
			when(item.itemId) {
			    R.id.iconDelete -> deleteNote(args.selectedNote)
			}
			return super.onOptionsItemSelected(item)
		    }

		    private fun deleteNote(selectedNote: Note) {
			noteViewModel.deleteNote(selectedNote)
			Toast.makeText(context, "Note successfully deleted!", Toast.LENGTH_SHORT).show()

			findNavController().navigate(R.id.action_notesUpdation_to_notesList)
		    }
		*/		    
//Values
	//Strings
		//Single item
		//<string name="app_name">CurrencyConverter</string>
		//Multiple items
		/* <string-array name="currency_codes">
        	<item>CAD</item>
        	<item>EUR</item>
        	<item>HKD</item>
        	<item>ISK</item>
        	<item>PHP</item>
		</string-array> */

//Condition
	//to check multiple coditions
		//use multiple if blocks just make sure to sepearate them
		
//Partion drive
	//How to partition a hard drive in Windows 10, and keep your most important files separate from the rest
		//https://www.businessinsider.com/how-to-partition-a-hard-drive-in-windows-10?IR=T

//AndroidX
	//AndroidX dependencies issue
		//Android Studio 3.6.1 | Error: “This project uses AndroidX dependencies” [duplicate]
		//ref - https://stackoverflow.com/questions/60506895/android-studio-3-6-1-error-this-project-uses-androidx-dependencies
		//To enable jetifier, add those two lines to your gradle.properties file:
		/* android.useAndroidX=true
		android.enableJetifier=true */
		//you need to replace old libraries with new ones by taking reference from new project

//google-services.json
	//File google-services.json is missing.
	//just add firebase to your project

//Environment  variable
	//just type environment to set environment variables
	//eg - jdk path

//Jetpack Compose
	//https://youtu.be/OOCivMK1v3s?t=304


//Project Structure
	//Adapter -> It will contain all adapter files
	//api -> it will contain api call functions && data classes for diff api calls in their respective packages
	//repository -> it will contain the repository file
	//UiActivities -> it will contain all activities related to UI
	//util -> Constants -> this file will contain the base_url for api calls
	//ViewModel -> it will contain viewmodel files for api calls 

//app icon
	//choose image
	//remove background , ref - https://www.remove.bg/upload
	//generate icon , ref - https://romannurik.github.io/AndroidAssetStudio/icons-	launcher.html#foreground.type=image&foreground.space.trim=1&foreground.space.pad=0.25&foreColor=rgba(255%2C%20255%2C%20255%2C%200)&backColor=rgb(255%2C%20255%2C%20255)&crop=0&backgroundShape=circle&effects=none&name=ic_launcher
	//copy files in res folder
	//change manifest file
	/* android:icon="@mipmap/ic_accenture"
	android:roundIcon="@mipmap/ic_accenture" */

//Function
	//global function
	/* fun setData() {
       	...
    	} */
	//you can declare this function and call this function from anywhere in the project	

//Keyboard shortcut
	//tab - make selection and press tab, It will move the entire section by tab space backwards
	//shift + tab - It will move the entire section by tab space forward
	//F2 - It will rename file
	//ctrl + shift + N - It will create new folder
	//ctrl + g - To go to particular line

//android dev challenge
	//ref - https://developer.android.com/dev-challenge?authuser=1#the-latest-challenge

//Eeegrab email ids
	//sanchaita@eegrab.com; kc@eegrab.com; pritam.s@eegrab.com; rohan.s@eegrab.com

//Difference between activity && fragment

	//activity - An Activity is an application component that provides a screen, with which users can interact in order to do something. 
	
	//fragment - Whereas a Fragment represents a behavior or a portion of user interface in an Activity.
	
	//Advantages of fragment
		//The main reason to use Fragments are for the backstack and lifecycle features.
		//Where I ran into trouble was with the back button and life cycle. Since I was simply updating views manually...there was nothing keeping track of the history 
		of views and their states. Therefore, the back button did not work as expected and it was difficult to recreate even the latest state during life cycle events, 
		such as when rotating the app. To fix that, I had to wrap my custom views in fragments and use the FragmentManager so that the previous states would be saved and recreated.
	
	ref - https://stackoverflow.com/questions/25822656/what-are-the-differences-between-activity-and-fragment
	
//Difference between ANR and crash in Android

	//ANR (Application Not Responding.) - An ANR will occur if you are running a process on the UI thread which takes a long time, usually around 5 seconds. During this 
	time the GUI (Graphical User Interface) will lock up which will result in anything the user presses will not be actioned. After the 5 seconds approx has occurred, if 
	the thread still hasn't recovered then an ANR dialogue box is shown informing the user that the application is not responding and will give the user the choice to 
	either wait, in the hope that the app will eventually recover, or to force close the app.
	
	//Crash - A crash is when an exception within the app has been thrown which has not been handled. For example, if you try to set the text of an EditText component, but 
	the EditText is null and there is no try catch statement to catch the exception then your app will crash and will be force closed. The user will not see what caused the 
	crash, they will be shown a dialogue telling that the app has force closed unexpectedly and will give them the option to send a bug report. In this example if you were 
	to look in the bug report you would see the error caused by java.lang.NullPointerException.
	
	ref - https://stackoverflow.com/questions/20213482/what-is-the-difference-between-anr-and-crash-in-android/20213896
	
//Dependency Version
	//'junit:junit:4.+' just replace + with random 3 digit nos eg 1.1.0 
	//implementation 'org.tensorflow:tensorflow-lite:2.4.0'
	
//Facial Recognition
	//course - https://www.udemy.com/course/image-recognition-in-android-one-hour-bootcamp-kotlin/learn/lecture/25078820#overview
	//software - https://teachablemachine.withgoogle.com/train
	//repo
		//for image classification from gallery
		https://github.com/hamza372/ImageclassificationKotlinStarter 
		//for image classification from live feed
		https://github.com/hamza372/LiveFeedImageClassificationKotlin
	//dependency - implementation 'org.tensorflow:tensorflow-lite:2.4.0'
	//app level gradle file
		// kotlinOptions {
        	jvmTarget = '1.8'
    		}
    		aaptOptions{		//it will not compress the tflite file while loading in android
        	noCompress "tflite"
    		}
//MVVM
	//ref - https://youtu.be/v2yocpEcE_g?t=3731
	//architecture
	/*
		Activity or Fragment
		ViewModel  (LiveData3)
		Repository
		Model -> Room -> SQLite		Remote Data Source -> Retrofit -> Webservice 
	//Notes
		In MVVM view doesnt interact with database directly. Instead it uses viewmodel for this. ViewModel contains all the business logic.
		Activity or Fragment only contains the UI and data part is handled by ViewModel like logical operations on data, updation or deletion of data.
		LiveData is used to notify about data change. View can observe LiveData for data change. LiveData is dependent of lifecycle and doesnt send notification about 
		data change if the activity or fragment is destroyed.
		
		Repository is used to access database whether locally or by server by viewmodel. ViewModel cannot access database directly without Repository.
	//ViewModel & LiveData Setup
		//TestViewModel
		/*
			class TestViewModel: ViewModel(){	//create ViewModel class and extend it with ViewModel 

			    var number = 0

			    val currentNumber: MutableLiveData<Int> by lazy {	//declare LiveData variables
				MutableLiveData<Int>()
			    }

			    val currentBoolean: MutableLiveData<Boolean> by lazy {
				MutableLiveData<Boolean>()
			    }
			}
		*/
		//MainActivity
		/*
			lateinit var viewModel: TestViewModel	//create ViewModel object
			onCreate {
				 viewModel = ViewModelProvider(this).get(TestViewModel::class.java)	//bind ViewModel object with ViewModel class
				 viewModel.currentNumber.observe(this, Observer {		//observe LiveData variable data change
				    binding.tvCount.text = it.toString()
				})
				incrementText()
			}
			private fun incrementText(){
			binding.btnCount.setOnClickListener {				
			    viewModel.currentNumber.value = ++viewModel.number			//update LiveData variable
			    viewModel.currentBoolean.value = viewModel.number % 2 == 0
				}
    			}
		*/			
//sharedpreferences 
	//Todo
	//Preferences DataStore (SharedPreferences deprecated)		

//Orientation Changes
	//how to retain data on orientation changes
	//onSaveInstanceState 
	//viewmodel and livedata

//R8	
	//R8 is more efficient than ProGuard 
	//Google released R8 as a replacement of Proguard to help developers shrink the code with the better-generated output (APK).
	//R8 uses Proguard rules to modify its default behavior.
	//tool to optimize your app for release
	//remove unused classes, functions and fields
	//remove unused resources eg - images
	//optimize the code itself eg - remove usused if statement or empty if statement
	//obfuscates your code eg - it will take all our classes, functions & variables and rename them to short unreadable names
	
	//mapping file
		//it will contain code for classes, variables, functions everything
		//you can use this to debug code when some user reports of crash in your release build
		//you can upload this file to play store alongwith your build and google will tell exactly which part of your 
		//code or classes has failed
		//location -> project -> C:\Users\Abhinesh Chandra\AndroidStudioProjects\R8Practice\app\build\outputs\mapping\release\mapping.txt
	
	//how to use
		//app gradle
		/*
		 buildTypes {
			release {
			    minifyEnabled true
			    shrinkResources true
			    proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
			}
    		}
		*/
		
	
	//proguard-rules.pro
		//we can use this to declare rules for proguard
		//eg - declare classes we dont want to obfuscates, optimize etc
		//eg - dont obfuscates data classes for json otherwise android will not be able to parse json bcs of variable mismatch
		
		//To ignore specific class
		//Code
		/*
		@Keep data class NewsResponse(  //It will ignore this particular class
    		val title: String
		)
		*/
		//To ignore multiple classes
		//proguard-rules.pro
		//Code
		/*
		-keep class com.example.r8practice.network.* { *; } // It will ignore all classes(network.*) of network package
		//{ *; } //It will ignore all funcs of all classes , you can specify a particular func also
		*/

//build variant
	//how to get release variant of the app
	//build -> select build variant -> debug or release
	//you can generate apk and you will get release variant

//Bundle apk
	//it will optimize the apk for diff devices
	//you app will be smaller for certain users

//Path
	//get path of any file in android
	//select file -> right click -> copy -> copy path -> absolute path or path from content root
	
//Physical location
	//get physical location of any file or package
	//select physical file or package -> rght clck -> show in explorer -> It will take you to location where your file is located

//Color Picker
	//you can pick color of images using this site
	//this site will show diff shades of image
	//ref - https://imagecolorpicker.com/en

//plugins
	//useful plugin for visual studio code
	//install && enjoy

//Custom Background
	//you can create a custom background using xml file
	//drawable -> new -> drawable resource file -> file name = button_custom_background && Root element = shape
	//custom_button.xml
	/*
	<?xml version="1.0" encoding="utf-8"?>
	<shape xmlns:android="http://schemas.android.com/apk/res/android"
    	android:shape="rectangle"
    	>
    	<solid android:color="#460073" />

    	<corners android:radius="50dp" />
	<stroke android:color="#4F4B53"
        android:width="2dp"
        />
	</shape>
	*/
	//Efficient way
		/* GradientDrawable shape =  new GradientDrawable();
                                        shape.setCornerRadius( 8 );
                                        shape.setColor(Color.GREEN);
                                        test_mqtt.setBackground(shape);
		*/
		//In this you dont need to create xml file for custom background
		//Also you can change the background dynamically

//Fragment
	//setup
	//activity_main
		<FrameLayout
		android:id="@+id/fragment_container"
		android:layout_width="match_parent"
		android:layout_height="match_parent"
		app:layout_constraintTop_toTopOf="parent"
		app:layout_constraintBottom_toBottomOf="parent"
		app:layout_constraintRight_toRightOf="parent"
		app:layout_constraintLeft_toLeftOf="parent"
		/>
	//MainActivity
		onCreate {
			val fragmentA = FragmentA()
        		supportFragmentManager.beginTransaction().replace(R.id.fragment_container,fragmentA).commit()
		}
	//pass data
		ref - https://github.com/abhineshchandra1234/Fragment-to-Fragment-Communication
		//data is passed using MainActivity
		//An Interface is used to pass data whose function is called in MainActivity

//Navigation Component
	//It is very powerful, It is used for handling navigation of fragments
	//It will preserve data even if the screen is rotated
	//Nav Graph
		//Create
			//res -> new Android resource file -> file_name = my_nav and file_type = navigation
		//Resource Manager -> Navigation -> + (new file) -> allow android to add libs -> my_nav
		//Add new Fragment
			//Create new destination -> Add Fragment
		//Home Icon
			//It represents the start destination
		//Start Destination
			//Fragment -> Rght clck -> set as start destination
		//activity_main.xml
			//add nav host fragment and fill complete screen
		//navigate to other screen
			/* 
				binding.tv1.setOnClickListener {
				Navigation.findNavController(view).navigate(R.id.navigateToSecondFragment) //R.id.navigateToSecondFragment is connecting link between two 
															screens
				}
			*/
		//Animations
			//Select action -> Animations -> enterAnim & exitAnim -> select your choice
			
	//Data passing 
		//you can use Serializable also to pass data, it work same as parcelable
		//diff between Serializable && parcelable
		//The reason is native code. Parcelable is created not just for interprocess communication.
		//It also can be used for intercode communication. You can send and 
		//recieve objects from C++ native layer. That's it.
		//code
			/*
				data class Article(
				    @PrimaryKey(autoGenerate = true)
				    var id: Int? = null,
				    val url: String,
				    val urlToImage: String
				) : Serializable
			*/	
		//between fragments
			//first create arguments using navigation component
			//create argument of type Serializable
			//first fragment
				/*
					 newsAdapter.setOnItemClickListener {
					    val bundle = Bundle().apply {
						putSerializable("article",it) //where article is the argument name
					    }
					    findNavController().navigate(
						R.id.action_breakingNewsFragment_to_articleFragment,
						bundle
					    )
					}
				*/	
			//second fragment
				/*
					val args: ArticleFragmentArgs by navArgs()
					onViewCreated {
						 val article = args.article
						webView.apply {
						    webViewClient = WebViewClient()
						    loadUrl(article.url)
						}
					}
				*/					
		//you can use parcelable data class to pass data or you can pass single values also. Data is passed using arguments.
		//plugin
			id 'kotlin-parcelize'
		//code
			/*
				@Parcelize
				data class ImageDetails(
				    val copyright: String,
				    val date: String,
				) :Parcelable
			*/
		//between fragments
			//first create arguments using navigation component
			//create argument of type Parcelable
			//first fragment
				/*
					 val action = ImageListDirections.actionImageListToImageDetails(imageList[position])
                			itemView.findNavController().navigate(action)
				*/
			//second fragment
				/*
					private val args by navArgs<ImageDecriptionArgs>()
					onViewCreated {
						tvTitle.text = args.ImageDetails.title
					}
				*/
	//Back Button
		//you can add back button for fragment by writing following code in main Activity
		//MainActivity
		/*
		 override fun onSupportNavigateUp(): Boolean {
			val navController = findNavController(R.id.navHostFragment)
			return navController.navigateUp() || super.onSupportNavigateUp()
		    }
		*/	
	//Plugins
		id "androidx.navigation.safeargs.kotlin"  //It is necessary to generate a directions file and the rest is handled by default
		classpath "androidx.navigation:navigation-safe-args-gradle-plugin:2.3.4"
	//Main.Xml
		/*
		<fragment
	       android:id="@+id/navHostFragment"
	       android:name="androidx.navigation.fragment.NavHostFragment"
	       android:layout_width="0dp"
	       android:layout_height="0dp"
	       app:defaultNavHost="true"
	       app:layout_constraintBottom_toBottomOf="parent"
	       app:layout_constraintEnd_toEndOf="parent"
	       app:layout_constraintStart_toStartOf="parent"
	       app:layout_constraintTop_toTopOf="parent"
	       app:navGraph="@navigation/my_nav" />
		*/	
	//Fragment
		//AppBar
			//rename app bar
			//my_nav -> android:label="Notes List"
//Competative Programming
	//https://www.codechef.com/
	//https://codeforces.com/

//gitignore
	//Personally, I don't commit ./idea/misc.xml and vcs.xml. I added them to .gitignore file. I'm using for this purpose template taken from: 
	https://github.com/github/gitignore/blob/master/Android.gitignore
	ref - https://stackoverflow.com/questions/39228464/android-studio-modifies-idea-vcs-xml-at-startup#:~:text=xml%20at%20startup,-
	android%20git%20android&text=since%20it's%20not%20recommended%20to%20ignore%20the%20entire%20.&text=xml%20constantly%20changes%20between%20JDK_1_7%20and%20JDK_1_8%20.
	//template
		ref - https://github.com/github/gitignore/blob/master/Android.gitignore

//setOnClickListener
	//efficient method to use
		/* 
		private fun incrementText(){
		binding.btnCount.setOnClickListener {
		    viewModel.currentNumber.value = ++viewModel.number
		    viewModel.currentBoolean.value = viewModel.number % 2 == 0
			}
	    	}	
    		*/

//Fragment
	//Fragment class
		/* 		
		class FirstFragment : Fragment(R.layout.fragment_first) {	//you dont need any methods inside of it 
			override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
				//do whatever you want to do
				//write some code
			}
		}
		*/
	//MainActivity
		/*
		onCreate {
			val firstFragment =  FirstFragment()
			supportFragmentManager.beginTransaction().apply {	//for default fragment
			    replace(R.id.flFragment, firstFragment)
			    commit()
			}
			binding.btnFragment1.setOnClickListener {
				    supportFragmentManager.beginTransaction().apply {		//to replace fragment on btn click
					replace(R.id.flFragment, firstFragment)
			//                addToBackStack(null) //to add stack
					commit()
				    }
				}
			}				
		*/
//MVVM project
	//https://youtu.be/xyzzokLRcCI - MVVM Habit Tracker App Tutorial in Android Studio

//Different States of icon
	//you can have your icons to display different backgrounds on different states . eg - it will have different background when it is selected or when focussed or hovered
	//for this you need to create one xml file and inside it specify different xml file for different state
	//drawable -> new -> drawable resource file -> file name = fastfood_selector && Root element = selector
	//fastfood_selector
	/*
	<?xml version="1.0" encoding="utf-8"?>
	<selector xmlns:android="http://schemas.android.com/apk/res/android">

	    <item android:drawable="@drawable/ic_outline_fastfood"
		android:state_selected="false"/>

	    <item android:drawable="@drawable/ic_fastfood"
		android:state_selected="true"/>
	</selector>
	*/
	//creating effect
	//pass the file as drawable resource to get the effect
		/*
		 <ImageView
                    android:id="@+id/iv_smokingSelected"
                    android:layout_width="100dp"
                    android:layout_height="100dp"
                    android:layout_margin="10dp"
                    android:layout_weight="1"
                    android:src="@drawable/smoking_selector" />
		    */
		    
//Fading effect
	//Code
	/*
	<ImageView

                android:id="@+id/iv_habit_icon"
                android:layout_width="140dp"
                android:layout_height="140dp"
                android:layout_margin="10dp"
                android:alpha=".1" //it will fade to 10 percent of its original value, if it was ".5" then it would have been faded to 50 percent of its original value
                android:src="@drawable/ic_tea" />
	*/		

//Parcelable data classes
	//Android Extensions plugin now includes an automatic Parcelable implementation generator. Declare the serialized properties in a primary constructor and add a 
	//@Parcelize annotation, and writeToParcel()/createFromParcel() methods will be created automatically:
	
	/*
	@Parcelize
	class User(val firstName: String, val lastName: String) : Parcelable
	*/
	
	So you need to enable them adding this to you module's build.gradle:
	
	/*
	id 'kotlin-android-extensions'

	android {
	    androidExtensions {
		experimental = true
	    }
	}
	*/
MVVM Habit Tracker App Tutorial - https://youtu.be/1NomRnyIUYo?t=779
//Migrate to androidX
	//refractor -> migrate to androidx
//Migrate to appCompat
	//refractor -> migrate to appCompat

//json file
	//you can read json file locally also
	//ref - https://stackoverflow.com/questions/56962608/how-to-read-json-file-from-assests-in-android-using-kotlin
	//activity
		/*
		val fileInString: String =
  		applicationContext.assets.open(fileName).bufferedReader().use { it.readText() }
		*/
	//fragment
		/*
		val fileInString: String =
            	context?.assets?.open("data.json")?.bufferedReader().use { it?.readText().toString() }
		*/

//Glide
	//to show images from url in recyclerview
		//Glide.with(holder.itemView.context).load("https://apod.nasa.gov/apod/image/1912/M94_Hubble_960.jpg").into(holder.itemView.imageView);

//ImageView
	/*
	<ImageView
	android:id="@+id/simpleImageView"
	android:layout_width="fill_parent"
	android:layout_height="wrap_content"
	android:src="@drawable/lion"
	android:scaleType="fitXY"/><!--set scale type fit xy--> <!--you can use this to adjust image inside imageView-->
	*/	

//Context
	//Activity
		//this, this@MainActivity
	//Fragment
		//context
	//Adapter
		//itemview.context, parent.context

//Maps App
	//ref - https://youtu.be/TN97RRR-7bk 
	//It will show basic map in your app and and static location
	//How to add marker on google map with Kotlin?(live location)
	ref - https://stackoverflow.com/questions/60465435/how-to-add-marker-on-google-map-with-kotlin
	/*
	map.setOnMapClickListener(object :GoogleMap.OnMapClickListener {
            override fun onMapClick(latlng : LatLng) {
                // Clears the previously touched position
                map.clear();
                // Animating to the touched position
                map.animateCamera(CameraUpdateFactory.newLatLng(latlng));

                val location = LatLng(latlng.latitude,latlng.longitude)
                map.addMarker(MarkerOptions().position(location).title("My Position"))
            }
        })
	*/

//Select opened file
	//there is an icon of cicle beside 1.Project tab, click on that it will show the location of opened file
	
//Timer
	//install plugin StopCoding and it will remind u to take break after regular interval

//Custom Spinner
	//ref - https://youtu.be/GeO5F0nnzAw

//Locker Tab
	//1280 * 800

//SVG File
	//you can use SVG file in android
	//use vector Asset to convert SVG file to XML file
	//and use it as a resource like background etc.

//Barcode && Qrcode scanner
	//Note - just make sure to check app's camera permission in phone
	//ref - https://youtu.be/drH63NpSWyk (video)
	//ref - https://github.com/yuriy-budiyev/code-scanner (docs)

//Room
	//Database - database
	//Dao - for operations on database
	//Database Inspector - you can use this to view the Database(table)
	//ref - https://gabrieltanner.org/blog/android-room
	
//Coroutines
	/*
	 private fun checkNumberStatus() {
		GlobalScope.launch {
		    Log.d("Main", "value is ${userViewModel.checkNumber(number)} ")
		}
	    }
	*/	   

//Coding Practice
	//https://leetcode.com/
	//partcipate in leetcode challenges to further improve your skills

//Code Template
	//ref - https://carbon.now.sh/
	//with this you can share code with beautiful template

//Ui
	//to create UI for android screen
	//use adobe xd 

//Snackbar
	//It will display a text at bottom of the screen
	//Code
	/*
		 Snackbar.make(view,"Successfully deleted article", Snackbar.LENGTH_LONG).apply {
                    setAction("Undo") {		//if you want to add some func to snackbar
                        viewModel.saveArticle(article)
                    }
                    show()
                }
	*/	
	
//Null check
	//oldArticles?.addAll(newArticles)
	//it means if oldArticles is not null then only newArticles will be added
	//whatever comes before "?" mark will be checked if it is null or not

//Differences between ConstraintLayout and RelativeLayout
	/* Intention of ConstraintLayout is to optimize and flatten the view hierarchy of your layouts by applying some rules to each view to avoid nesting.
		Rules remind you of RelativeLayout, for example setting the left to the left of some other view.
		app:layout_constraintBottom_toBottomOf="@+id/view1"
	Unlike RelativeLayout, ConstraintLayout offers bias value that is used to position a view in terms of 0% and 100% horizontal and vertical offset relative to the handles 
	(marked with circle). These percentages (and fractions) offer seamless positioning of the view across different screen densities and sizes.
	app:layout_constraintHorizontal_bias="0.33" <!-- from 0.0 to 1.0 -->
	app:layout_constraintVertical_bias="0.53" <!-- from 0.0 to 1.0 -->
	ref - https://stackoverflow.com/questions/37321448/differences-between-constraintlayout-and-relativelayout
	*/		

//MVVM courses to be done
	//Project Setup - MVVM Image Search App with Architecture Components & Retrofit #1
	ref - https://youtu.be/m_cMJehM9xc
	//for caching
	//Simple Offline Caching With NetworkBoundResource + Kotlin Coroutines (Flow)
	ref - https://youtu.be/idaPtfckRx4


//Shape
	//Gradient
		  /* <gradient
			android:startColor="#00FFFFFF"
			android:endColor="#000"  //it will create a nice rectangle box with transparent start color and dark end color
			android:angle="270"
			/> */

//Packages
	//setting
	//just deselect "Compact middle packages" and you will be able to see empty sub packages easily

//Dagger - Hilt
	//Is ApplicationComponent deprecated?
		//ApplicationComponent being renamed to SingletonComponent, to allow usage of Hilt in non-Android Gradle modules link
	//it allows repository to be injected in ViewModel class without the need of creating ViewModelFactory class
	//@ViewModelInject is deprecated use @Inject instead
	//Injecting ViewModel with Dagger Hilt
	//ref - https://medium.com/mobile-app-development-publication/injecting-viewmodel-with-dagger-hilt-54ca2e433865

//Flows 
	//flows is more efficient than livedata
	//it can perform more tasks than livedata
	//it works on the producer-consumer principle
	//if there is delay on either side then there will be delay in result
	//if consumer is taking time to process data then producer will delay sending of data
	//Code
	/*
	 val flow = flow {
            for(i in 1..10) {
                emit(i)		//It will act as producer
                delay(1000L)
            }
        }
	
	GlobalScope.launch {
            flow.collect {
                println(it)	//It will act as consumer //it will print data after delay of every one sec        
            }
        }
	
	GlobalScope.launch {
            flow.collect {
                println(it)	//it will print data after delay of every three sec   
		delay(2000L)	//output 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
            }
        }
	
	GlobalScope.launch {
            flow.buffer().collect {
                println(it)	//it will print data after delay of every two sec   //buffer will retain data and provide to consumer when it is free
		delay(2000L)	//you have to be careful with buffer bcs it has fixed size
            }			//output 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
        }
	
	GlobalScope.launch {
            flow.buffer().filter{ //it will filter && map data then it will print result
                it % 2 == 0	//output 4, 16, 36, 64, 100
            }.map{
                it * it
            }.collect {
                println(it)
                delay(2000L)
            }
        }

//gradle issue
	//Delete .gradle folder(root directory) and build folder(project directory) and then invalidate caches/restart android studio, run your project again hopefully it will 
	//work. It might take some time for the background tasks. In some countries, you may need to turn on the VPN to download.
	ref - https://stackoverflow.com/questions/29808199/error-running-android-gradle-project-sync-failed-please-fix-your-project-and-t
	//How to delete locked files on Windows 10
	//Safe Mode
	//In safe mode, users can typically delete most files as Windows only loads up the necessary and most essential processes and resources to run.
	//ref - https://mspoweruser.com/delete-locked-files-windows-10/


//Difference between ASyncTask && Service
	//ASyncTask
		//It is used for small operations
		//AsyncTask s are designed for once-off time-consuming tasks that cannot be run of the UI thread.
		//A common example is fetching/processing data when a button is 
		//pressed.
	//Service
		//It is used for large operation
		//Service s are designed to be continually running in the background. 
		//services do not necessarily run off of the UI thread.
		 
//Android Launch Mode
	//There are four launch modes for activity.
		//standard, singleTop, singleTask, singleInstance
		//ref - https://medium.com/mindorks/android-launch-mode-787d28952959
		TODO()
	//Is there any launch modes for fragments like Activity launch modes?
		//FragmentManager allows you to retrieve Fragments from the back stack:
		findFragmentById(int)
		findFragmentByTag(String)
